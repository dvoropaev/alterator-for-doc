= Alterator-manager-services =

= Спецификация =

== Введение ==
Спецификация альтератор-сервис перекликается с уже существующей спецификацией "[https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html desktop entries]" файлов. Спецификация взята для увеличения порога вхождения в разработку модулей: сервис, за счет схожести с уже существующей спецификацией. Спецификация отразит схожие и различные свойства alterator entries и desktop entries необходимые для работы Alterator-manager-services.

== Именование файлов ==
Alterator entry файлы должны заканчиваться на .desktop - расширение файла. В данной спецификации не предусмотрено использование директорий и разбор файлов не включающих необходимое разрешение файла.

Для сервисов, часть имени файла до .desktop разрешения должна соответствовать D-BUS именованию. То есть это последовательность не пустых элементов, разделенных точками (U+002E FULL STOP), ни одина из которых не начинается с цифры, и каждая из которых содержит только символы из набора [A-Za-z0-9- _]: буквы ASCII, цифры, тире (U+002D ДЕФИС-МИНУС) и подчеркивание (U+005F LOW LINE).
Имя должно соответствовать соглашению об обратном DNS именовании: оно должно начинаться с обратного доменного имени DNS,

Имя должно соответствовать соглашению об обратном DNS именовании: оно должно начинаться с обратного доменного имени DNS, org.altlinux в нижнем регистре. За доменным именем должно следовать название сервиса, которое обычно пишется слитными словами и начальными заглавными буквами (CamelCase). Например, если имя сервиса "Foo Viewer", пример именования выглядит так: org.altlinux.service.FooViewer.desktop.

Общеизвестные имена, содержащие тире, разрешены в спецификации, но не рекомендуются, потому что тире не разрешено в некоторых связанных случаях использования обратных имен DNS, таких как пути к объектам D-Bus и имена интерфейсов, а также идентификаторы приложений Flatpak. Если доменное имя автора содержит тире, рекомендуется заменить его символом подчеркивания: это не может привести к двусмысленности, поскольку использование подчеркивания в доменных именах DNS запрещено.

Если имя сервиса содержит метку, начинающуюся с цифры (что не разрешено в общеизвестных именах D-Bus), рекомендуется добавить подчеркивание к этому элементу имени.

=== Идентификатор Alterator entry ===
TODO! Нужно переработать.
Каждая запись Alterator entry, представляет сервис, идентифицируется своим идентификатором файла рабочего стола, который основан на его имени файла.
Каждая запись рабочего стола, представляющая приложение, идентифицируется своим идентификатором файла рабочего стола, который основан на его имени файла.

Чтобы определить идентификатор файла рабочего стола, сделайте его полный путь относительно компонента $XDG_DATA_DIRS, в котором установлен файл рабочего стола, удалите префикс "applications/" и замените "/" на "-".

Например, /usr/share/applications/foo/bar.desktop имеет идентификатор файла рабочего стола foo-bar.desktop.

Если несколько файлов имеют одинаковый идентификатор файла рабочего стола, используется первый в порядке приоритета $XDG_DATA_DIRS.

Например, если $XDG_DATA_DIRS содержит пути по умолчанию /usr/local/share:/usr/share, тогда /usr/local/share/applications/org.foo.bar.desktop и /usr/share/applications/org.foo .bar.desktop имеют одинаковый идентификатор файла рабочего стола org.foo.bar.desktop, но будет использоваться только первый из них.

Если оба foo-bar.desktop и foo/bar.desktop существуют, не определено, какой из них выбран.

Если файл рабочего стола не установлен в подкаталоге приложений одного из компонентов $XDG_DATA_DIRS, у него нет идентификатора.

== Базовый формат файла==
Alterator entry файлы записываются в кодировке UTF-8. Файл интерпретируется как последовательность регистрозависимых строк, разделенных символом перевода строки.

CHECKIT! Не понимаю назначения функционала
Совместимы расширения НЕ ДОЛЖНЫ исключать обязательных полей, не смотря на то что поля могут не поддерживаться сервисом. Такие поля должны записаны списком в любом месте файла, и если файл будет перезаписан, они должны быть включены. Это гарантирует, что любые расширения будут сохранены, даже если другая система получит доступ к файлу и изменит его.

        Оригинал из спецификации:
        Desktop entry files are encoded in UTF-8. A file is interpreted as a series of lines that are separated by linefeed characters. Case is significant everywhere in the file.

        Compliant implementations MUST not remove any fields from the file, even if they don't support them. Such fields must be maintained in a list somewhere, and if the file is "rewritten", they will be included. This ensures that any desktop-specific extensions will be preserved even if another system accesses and changes the file.

=== Коментарии ===
Строки, начинающиеся с #, и пустые строки считаются комментариями и будут игнорироваться, однако их следует сохранять при чтении и записи файла записи рабочего стола.

Строки комментариев не интерпретируются и могут содержать любые символы (кроме LF --- перенос строки). Рекомендуется использовать кодировку UTF-8 для строк комментариев, содержащих символы, отличные от ASCII.

=== Заголовки групп ===
Заголовок группы с именем <code>groupname</code> это строка в формате:

<code>[groupname]</code>

Имена груп могут содержать любые ASCII символы исключая [ и ] и управлющих символоы.

Группы не могут иметь одинаковые имена.

Любые пары <code>{key,value}</code> следующие после заголовка группы пренадлежат обозначенной группе, до того пока не появится строка с заголовком новой группы.

Базовый формат файла записи Alterator entry требует наличия заголовка группы с именем Alterator Entry. В файле могут присутствовать и другие группы, но это самая важная группа, которая обязательно должна присутствовать. Перед этой группой в файле записи на рабочем столе не должно быть ничего, кроме, возможно, одного или нескольких комментариев.
CHECKIT! Не понимаю назначения функционала - >>Эту группу также следует использовать в качестве "magic key" для автоматического определения типа MIME.

=== Записи ===

[[#«Записи»]]
Запись в файле это пара <code>{key,value}</code> в формате:

<code>Key=Value</code>

Пробел до и после знака равенства игнорируются. знак <code>=</code> игнорируется.

Только знаки <code>A-Za-z0-9-</code> могут использоваться в имени ключа.

Имена ключей регистро зависимы имя <code>name</code> и <code>NAME</code> не эвивалентны.

Несколько ключей в одной группе не могут иметь одинаковое имя. Ключи в разных группах могут иметь одинаковые имена.

== Возможные типы значений ==

Доступные типы значений <code>string, localestring, iconstring, boolean, numeric</code>.
*Значение типа <code>string</code> может содержать любые ASCII  символы исключая контрольные символы.
*Значение типа <code>localestring</code> строки отображаются пользователю, и кодируются в UTF-8.
*Значения типа <code>iconstring</code> названия иконок; могут быть абсолютные пути или символические имена для значков, определяемых с использованием алгоритма, описанного в [http://freedesktop.org/wiki/Standards/icon-theme-spec Спецификации темы значков]. Такие значения не отображаются пользователю и кодируются в UTF-8.
*Значения типа <code>boolean</code> должны быть либо строкой <code>true</code> либо <code>false</code>.
*Значения типа <code>numeric</code> должно быть валидным числовм значением с плавающей точкой как лпределенов <code>%f</code> спецификации для </code>scanf</code> в <code>C</code> локали.

У правляющеие символы <code>\s, \n, \t, \r и \\</code> поддерживаются для значений типа <code>string, localestring и iconstring </code> и означают пробел, новую строку, знак табуляции, возврат коретки и косая черта соответственно.

Некоторые ключи могут иметь множественные значения. В некоторых случаях, значения ключей определено как множдественное: для примера, <code>string(s)</code>. Множественные значения должны быть разделены точкой с запятой и значния ключей могут быть опционально разделены точкой с запятой. Завершающие пустые строки всегда должны разделятся точкой с запятой. точка с запятой как значение должна быть экранирована и использованим знака <code>\;</code>.


== Локализация значений для ключей ==

Ключ с типом <code>localestring</code> и <code>iconstring</code> могут содержать постфикс <code>[LOCAELE]</code>, где <code>LOCAELE</code> это тип локали записи. <code>LOCAELE</code> должен быть <code>lang_COUNTRY.ENCODING@MODIFIER</code>, где <code>lang_COUNTRY.ENCODING</code> и <code>@MODIFIER</code> могут быть опущены. Если встречается ключ с постфиксом, то тот же ключ должен присутствовать и без постфикса.

Когда читается запись файла Alterator Entry, значение ключа выбирается по сопоставлению текущей POSIX локали для значения <code>LC_MESSAGES</code> с постфиксом <code>LOCAELE</code> всех вхождений ключа с удаленной сачатью .ENCODING.


Сопоставление осуществляется следующим образом. Если LC_MESSAGES имеет вид <code>lang_COUNTRY.ENCODING@MODIFIER</code>, то он будет соответсвовать ключу вида <code>lang_COUNTRY@MODIFIER</code>. Если такого ключа не существует, сопоставляется <code>lang_COUNTRY</code>, сосответсвющий <code>lang@MODIFIER</code>. Затем будет предпринята попытка сопоставления с <code>lang</code>. Если соответствующий ключ не найден, используется установленный ключ без указанной локали. Кодировка из значения <code>LC_MESSAGES</code> игнорируется при сопоставлении.

'''Таблица 1. Сопоставление локали'''

{| class="wikitable" style="margin:auto"
|+ Caption text
|-
! '''Значение LC_MESSAGES''' !! '''Возможный порядок сопоставления ключей'''
|-
| lang_COUNTRY@MODIFIER || lang_COUNTRY@MODIFIER, lang_COUNTRY, lang@MODIFIER, lang, значение поумолчанию
|-
| lang_COUNTRY || lang_COUNTRY, lang, значение поумолчанию
|-
| lang@MODIFIER || lang@MODIFIER, lang, значение поумолчанию
|-
| lang || lang, значение поумолчанию
|}

Для примера, если текущее значение <code>LC_MESSAGES</code> равно <code>sr_YU@Latn</code> и Alterator entry файл содержит:

<code>
 Name=Foo
 Name[sr_YU]=...
 Name[sr@Latn]=...
 Name[sr]=...
</code>

тогда значение ключа <code>Name</code> будет взято с постфиксом <code>sr_YU</code>.

Хотя имена значков типа <code>iconstring</code> можно локализовать, они не являются удобочитаемыми строками, поэтому обычно не должны обрабатываться средствами перевода. Большинство приложений не должны локализовать свои значки; исключения могут включать значки, содержащие текст или символы, характерные для данной культуры.

== Общепринятые Alterator entry ключи ==

Ключи бывают ДОПОЛНИТЕЛЬНЫМИ или ТРЕБУЕМЫМИ. Если ключ ДОПОЛНИТЕЛЬНЫЙ, он может присутствовать или отсутствовать в файле. Однако, если это не так, реализация стандарта не должна давать сбоев, она должна обеспечивать разумные значения по умолчанию.

Некоторые ключи имеют смысл только в том контексте, когда присутствует другой специфичный ключ, которому присвоено определенное значение. Эти ключи не следует использовать, если его специфичный ключ отсутствует или не установлен в определенное значение. Например, ключ <code>Terminal</code> можно использовать только в том случае, если значением ключа типа является <code>Application</code>.

Если НЕОБХОДИМЫЙ ключ действителен только в контексте другого ключа, установленного на определенное значение, то он должен присутствовать только в том случае, если другой ключ установлен на определенное значение. Например, ключ URL должен присутствовать тогда и только тогда, когда значением ключа <code>Type</code> является <code>Link</code>.

Несколько примеров ключей: <code>Name[C]</code>, <code>Comment[it]</code>.

'''Таблица 2. Стандартные ключи'''

{| class="wikitable" style="margin:auto"
|+ Caption text
|-
! '''Ключ''' !! '''Описание''' !! '''Тип значения''' !! '''Обязательный'''
|-
| Type || Значение определяющее тип групп, в зависимости от группы принимает различне значения. Пример значения: Service, File, Directory, ldb, tdb  ( Напоминание Type={application|service|category} необходимо ли для основной секции Alterator entry? ) || string || Да
|-
| Version || CHECKIT! Возможно, нет необходимости || string || Нет
|-
| Name || Определенное имя сущности обозначенной в групее || string || Да
|-
| GenericName || CHECKIT! Общепринятое имя || string || Нет
|-
| NoDisplay || CHECKIT! Возможно нет необходимости. Оригинальное назначение кратко "Не отображать в меню" || boolean || Нет
|-
| Comment || CHECKIT! Возможно нет необходимости. Оригинальное назначение "Подсказка к записи, например "Просмотр сайтов в Интернете". Это значение не должно совпадать со значениями Name и GenericName." || string || Некоторые
| Icon || Отображемая специфичная иконка. Если имя представляет собой абсолютный путь, будет использоваться данный файл. Если имя не является абсолютным путем, для поиска значка будет использоваться алгоритм, описанный в [http://freedesktop.org/wiki/Standards/icon-theme-spec  Спецификации темы значка]. || string || Нет
|-
| Hidden || CHECKIT! Возможно нет необходимости. Эквивалентно отсутвию Alterator entry, то же самое что файл не существует. || string || Нет
|-
| OnlyShowIn, NotShowIn || || ||
|-
| DBusActivatable || || ||
|-
| TryExec || Путь к исполняемому файлу на диске, используемый для определения того, действительно ли установлена программа(сервис). Если путь не является абсолютным, файл ищется в переменной среды $PATH. Если файл отсутствует или не является исполняемым, запись можно игнорировать (например, не использовать в меню (не отображать в интерфейсе)). || string || Нет
|-
| Exec || CHECKIT! Размышления из бесед и записей: Object %O [[#Описание Exec]] || string ||
|-
| Path || Путь к элементу описаннному в группе или рабочая дирректория. Актуален не для всех групп. || string || Нет
|-
| Terminal || || boolean || Нет
|-
| Actions || CHECKIT! Возможно нет необходимости. "Идентификаторы действий приложения. Это можно использовать, чтобы указать приложению выполнить определенное действие, отличное от поведения по умолчанию. В разделе "Действия приложения" описывается, как работают действия." || string(s) || Нет
|-
| MimeType || Поддерживаемый MIME тип(ы) || string(s) || Нет
|-
| Categories || Категории отображемые в интерфейсе. [[#Спецификация категорий]]. Актуально не для всех групп. Пример: samba, dhcp,DNS, webserver || string(s) || Нет
|-
| Implements || [[#Интерфейсы]] Список интерфейсов, которые реализует Alterator entry. || string(s) || Нет
|-
| Keywords || Дополнительный список ключевых слова для поиска внутри интерфейса. Не должно совпадать с значениями <code>Name</code> и <code>GenericName</code>. || localestring(s) || Нет
|-
| StartupNotify ||  || boolean || Нет
|-
| StartupWMClass ||  || boolean || Нет
|-
| URL || Присутствует если запись группа обладает URL  характиристикой || string || Нет
|-
| PrefersNonDefaultGPU || || boolean || Нет
|-
| SingleMainWindow || || boolean || Нет
|-
! '''Ключ''' !! '''Описание''' !! '''Тип значения''' !! '''Обязательный'''
|-
| Object || /<уникальное имя объекта> || string || Да
|-
| CategoryName || Уникальное имя внитри категории UID || string || Да
|-
| Resources || [[#Список типов ресурсов]] исползуемых описанным Alterator entry || string(s) || Да
|-
| Started || Состояние ресурса отражающее сатутс -- запущено. В случае неопределенного состояния значение так же равно false. || boolean || Да
|-
| Enabled || Состояние ресурса отражающее сатутс -- запускается поумолчанию при старте системы. В случае неопределенного состояния значение так же равно false. || boolean || Да
|-
| Configured || Состояние ресурса отражающее сатутс -- сконфигурировано, конфигурация определена и валиндна. В случае неопределенного состояния значение так же равно false. || boolean || Да
|-
| Description || !!CHECKIT к исполняемому файлу с параметрами, реализующему вывод необходимого описания в соответсвии с локалью. || string || Да
|-
| Description || !!CHECKIT к исполняемому файлу с параметрами, реализующему вывод необходимого описания в соответсвии с локалью. ||l
|}


== Ключ Exec Выполнение-запуск ==

[[#Описание EXEC]]
Ключ Exec должен содержать командную строку. Командная строка состоит из исполняемой программы, за которой может следовать один или несколько аргументов. Исполняемую программу можно указать либо с полным путем, либо только с именем исполняемого файла. Если полный путь не указан, исполняемый файл ищется в переменной среды $PATH, используемой рабочей средой. Имя или путь исполняемой программы не могут содержать знак равенства ("="). Аргументы разделяются пробелом.

Аргументы можно передается целиком. Если аргумент содержит зарезервированный символ, аргумент необходимо заключить в кавычки. Правила заключения аргументов в кавычки также применимы к имени исполняемого файла или пути к исполняемой программе, как передано.

Заключение в кавычки должно осуществляться путем заключения аргумента в двойные кавычки и экранирования символа двойной кавычки, символа обратной галочки ("`"), знака доллара ("$") и символа обратной косой черты ("\"), экранируя его дополнительным символом обратной косой черты. Реализации должны отменить кавычки перед раскрытием кодов полей и перед передачей аргумента исполняемой программе. Зарезервированные символы: пробел (""), табуляция, новая строка, двойная кавычка, одинарная кавычка ("'"), символ обратной косой черты ("\"), знак "больше" (">"), знак "меньше" ("<" ), тильда ("~"), вертикальная черта ("|"), амперсанд ("&"), точка с запятой (";"), знак доллара ("$"), звездочка ("*"), вопросительный знак (" ?"), решётка ("#"), круглые скобки ("(") и (")") и обратный апостроф ("`").

Обратите внимание, что общее правило экранирование для значений строкового типа гласит, что символ обратной косой черты также может быть экранирован как ("\\") и что это правило экранирования применяется перед правилом кавычек. Таким образом, для однозначного представления символа обратной косой черты в аргументе в кавычках в файле Alterator entry требуется использование четырех последовательных символов обратной косой черты ("\\\\"). Аналогично, знак доллара в аргументе в кавычках в файле записи рабочего стола однозначно обозначается ("\\$").

!CHECKIT
Определен ряд специальных кодов полей, которые будут расширены файловым менеджером или средством запуска программ при обнаружении в командной строке. Коды полей состоят из символа процента («%»), за которым следует буквенный символ. Буквальные процентные символы должны быть экранированы как %%. Устаревшие коды полей следует удалить из командной строки и игнорировать. Коды полей раскрываются только один раз, строку, которая используется для замены кода поля, не следует проверять на наличие кодов полей.

Командные строки, содержащие поля с кодом подстановки не указанные в этой спецификации, недействительны и не должны обрабатываться, в частности, реализации могут не обеспечивать поддержку кодов полей, не перечисленных в этой спецификации. Расширения, если таковые имеются, следует вводить посредством нового ключа.

Реализации должны позаботиться о том, чтобы не разрешать коды полей на несколько аргументов, если это явно не указано в этой спецификации. Это означает, что поля имен, имена файлов и другие замены, которые могут содержать пробелы, должны передаваться в качестве одного аргумента исполняемой программе после развертывания.

Хотя ключ <code>Exec</code> определен как имеющий значение типа строки, которое ограничено символами ASCII, расширение кода поля может включать в аргументы символы, отличные от ASCII. Реализации должны позаботиться о том, чтобы все символы в аргументах, передаваемых исполняемой программе, были правильно преобразованы в соответствии с применимыми настройками локали.


Распознаются следующие коды:

{| class="wikitable" style="margin:auto"
|+ Caption text
|-
! '''Код(!CHECKIT?Плэйсхолдер?)''' !! '''Описание'''
|-
| %f || Одно имя файла (включая путь), даже если выбрано несколько файлов. Система, читающая запись на рабочем столе, должна распознавать, что рассматриваемая программа не может обрабатывать несколько аргументов файла, и ей, вероятно, следует создать и выполнить несколько копий программы для каждого выбранного файла, если программа не может обрабатывать дополнительные аргументы файла. Если файлы находятся не в локальной файловой системе (т. е. находятся в расположениях HTTP или FTP), файлы будут скопированы в локальную файловую систему, а %f будет расширен, чтобы указать на временный файл. Используется для программ, которые не понимают синтаксис URL.

|-
| %F || Список файлов. Используйте для приложений, которые могут открывать несколько локальных файлов одновременно. Каждый файл передается как отдельный аргумент исполняемой программе.
|-
| %u || Один URL-адрес. Локальные файлы могут передаваться как URL-адреса файлов или как путь к файлу.
|-
| %U || Список URL-адресов. Каждый URL-адрес передается как отдельный аргумент исполняемой программе. Локальные файлы могут передаваться как URL-адреса файлов или как путь к файлу.
|-
| %i || <code>Icon</code> ключ Alterator entry разворачивается как два аргумента, первый <code>--icon</code> и второй значение ключа <code>Icon</code>.  Icon key is empty or missing.
|-
| %c || Переведенное в соответсви с локалью значение ключа <code>Name</code>
|-
| %k || Местоположение файла Alterator entry в виде URI (если, например, он получен из системы vfolder), либо локального имени файла, либо пустого значения, если местоположение неизвестно.
|}

Командная строка может содержать не более одного кода %f, %u, %F или %U. Коды не должны использоваться внутри аргумента в кавычках, результат расширения кода поля внутри аргумента в кавычках не определен. Коды полей %F и %U можно использовать только в качестве аргумента.


== D-Bus Активация ==

!CHECKIT Просто перевод. Не знаю как

Приложения, поддерживающие запуск через D-Bus, должны реализовать следующий интерфейс (данный в формате XML для интроспекции D-Bus):

<code>
  <interface name='org.freedesktop.Application'>
    <method name='Activate'>
      <arg type='a{sv}' name='platform_data' direction='in'/>
    </method>
    <method name='Open'>
      <arg type='as' name='uris' direction='in'/>
      <arg type='a{sv}' name='platform_data' direction='in'/>
    </method>
    <method name='ActivateAction'>
      <arg type='s' name='action_name' direction='in'/>
      <arg type='av' name='parameter' direction='in'/>
      <arg type='a{sv}' name='platform_data' direction='in'/>
    </method>
  </interface>
</code>

Приложение должно назвать свой файл рабочего стола в соответствии с рекомендациями по именованию во вводном разделе (например, имя файла должно иметь вид org.example.FooViewer.desktop). Приложение должно иметь службу D-Bus, активируемую под общеизвестным именем, равным имени файла рабочего стола с удаленной частью .desktop (в нашем примере org.example.FooViewer). Вышеупомянутый интерфейс должен быть реализован по пути к объекту, определенному следующим образом: начиная с хорошо известного имени приложения D-Bus, замените все точки на косые черты и добавьте косую черту в качестве префикса. Если обнаружено тире ('-'), преобразуйте его в подчеркивание ('_'). В нашем примере это /org/example/FooViewer.

Метод <code>Activate</code> вызывается, когда приложение запускается без файлов для открытия.

Метод <code>Open</code> вызывается, когда приложение запускается с файлами. Массив строк представляет собой массив URI в UTF-8.

Метод <code>ActivateAction</code> вызывается, когда активируются действия рабочего стола. Параметр action-name — это имя действия.

Все методы принимают аргумент данных платформы, который используется аналогично переменным среды. Текущие поля, описанные в спецификации:

     <code>Desktop-startup-id</code>: это должна быть строка того же значения, которая будет храниться в переменной среды <code>DESKTOP_STARTUP_ID</code>, как указано в спецификации протокола уведомления о запуске.

     <code>activation-token</code>: это должна быть строка того же значения, которая будет храниться в переменной среды <code>XDG_ACTIVATION_TOKEN</code>, как указано в протоколе активации XDG для Wayland.

== Интерфейсы ==

[[#Интерфейсы]]

Ключ <code>Implements</code> можно использовать для объявления одного или нескольких интерфейсов, которые реализует файл рабочего стола.

Каждое имя интерфейса должно соответствовать правилам, используемым для имен интерфейсов D-Bus, но кроме этого они не имеют особого значения. Например, указание здесь интерфейса не обязательно означает, что это приложение реализует этот интерфейс D-Bus или даже что такой интерфейс D-Bus существует. Определение того, что означает его реализация, полностью зависит от сущности, которая определила конкретный интерфейс.

Хотя решение о том, что означает данное имя интерфейса, полностью зависит от разработчика интерфейса, вот несколько рекомендуемых «лучших практик»:

   *   интерфейсы должны требовать, чтобы приложение было DBusActivatable, включая требование, чтобы файл рабочего стола приложения назывался с использованием соглашения «обратного DNS» D-Bus.

   *  имя интерфейса должно соответствовать интерфейсу D-Bus, который приложение экспортирует по тому же пути к объекту, что и интерфейс org.freedesktop.Application.

   *  если интерфейс желает разрешить подробную информацию о реализации, он должен сделать это, указав, что разработчики добавляют в свой файл рабочего стола группу с тем же именем, что и интерфейс (например: «[org.freedesktop.ImageAcquire]»)

Несмотря на рекомендации, интерфейсы могут указывать практически любые мыслимые требования, включая такие (смехотворные) вещи, как «при запуске через строку Exec ожидается, что приложение представит окно с набором свойств _FOO_IDENTIFIER, после чего сообщение X-клиента будет отправлено на это окно». Другой пример: «ожидается, что все реализации этого интерфейса будут помечены как NoDisplay, при запуске не будут отображать окна и будут удалять все файлы пользователя без подтверждения».

Разработчики интерфейсов должны позаботиться о том, чтобы учитывать вопросы обратной и прямой совместимости при проектировании своих интерфейсов.

== Регистрация MIME типов ==

!CHECKIT Перевод из руководства. вероятно не нужен.

Ключ <code>MimeType</code> используется для указания типов MIME, которые приложение умеет обрабатывать. Ожидается, что для некоторых приложений этот список может стать длинным. Ожидается, что приложение сможет открывать файлы этих типов с помощью команды, указанной в ключе Exec.

В этом поле не должно быть приоритета для типов MIME или какой-либо формы приоритета в файле рабочего стола. Приоритет приложений обрабатывается вне файлов .desktop.


== Дополнительный функционал приложения ==

Desktop entries типа Приложение могут включать одно или несколько действий. Действие представляет собой дополнительный способ вызова приложения. Средства запуска приложений должны предоставлять их пользователю (например, в виде подменю) в контексте приложения. Это используется для создания так называемых «быстрых списков» или «списков перехода».

=== Идентификатор действия ===

Каждое действие идентифицируется строкой, имеющей тот же формат, что и имена клавиш (см. раздел [[#«Записи»]]). Каждый идентификатор связан с группой действий, которая должна присутствовать в файле .desktop. Группа действий — это группа с именем <code>Desktop Action</code> стола %s, где <code>%s</code> — идентификатор действия.

Недопустимо иметь группу действий для идентификатора действия, не упомянутого в ключе <code>Actions</code>. Реализаторы должны игнорировать такую группу действий.

=== Table 3. Action Specific Keys ===

{| class="wikitable" style="margin:auto"
|+ Caption text
|-
! '''Ключ''' !! '''Описание''' !! '''Тип значения''' !! '''Обязательный'''
| Name || Ярлык, который будет показан пользователю. Поскольку действия всегда отображаются в контексте конкретного приложения (то есть в виде подменю средства запуска), это должно быть однозначным только в пределах одного приложения и не должно включать имя приложения. || localestring || Да
|-
| Icon || Отображемая специфичная иконка. Если имя представляет собой абсолютный путь, будет использоваться данный файл. Если имя не является абсолютным путем, для поиска значка будет использоваться алгоритм, описанный в [http://freedesktop.org/wiki/Standards/icon-theme-spec  Спецификации темы значка]. || iconstring || Нет
|-
| Exec || Программа, выполняемая для этого действия, возможно, с аргументами. Подробную информацию о том, как работает этот ключ, см. в разделе <code>Exec</code>. Ключ <code>Exec</code> необходим, если для <code>DBusActivatable</code> не установлено значение true в основной группе записей рабочего стола. Даже если <code>DBusActivatable</code> имеет значение true, Exec следует указать для совместимости с реализациями, которые не понимают <code>DBusActivatable</code>. || string || Нет
|}


Замечания по реализации

Aplication Actions должны поддерживаться разработчиками. Однако, если они не поддерживаются, разработчики могут просто игнорировать ключ <code>Action</code> и связанные с ней группы <code>Desktop Action</code> действий рабочего стола и продолжать использовать группу <code>Desktop Action</code>: основной способ описания и вызова приложения — через клавиши «Имя», «Значок» и «Выполнение». из группы <code>Desktop Entry</code>.

Не ожидается, что другие компоненты рабочего стола, отображающие списки приложений (например, установщики программного обеспечения), будут предоставлять какой-либо пользовательский интерфейс для этих действий. Поэтому приложения должны включать только те действия, которые имеют смысл в качестве общих средств запуска.

== Расширение формата ==

Если в стандарт необходимо внести новую пару <code>{ключ, значение}</code>, которая должна быть применима ко всем поддерживающим сторонам, будет проведено групповое обсуждение. Это предпочтительный метод внесения изменений. Если одна конкретная сторона желает добавить для личного использования, ей следует поставить перед ключом строку <code>X-PRODUCT</code>, например: <code>X-NewDesktop-Foo</code>, следуя прецеденту, установленному другими стандартами IETF и RFC.

В качестве альтернативы поля можно поместить в отдельную группу, где они могут иметь произвольные ключевые имена. В этом случае группа должна следовать схеме, описанной выше, то есть <code>[X-PRODUCT GROUPNAME]</code> или что-то подобное. Эти шаги позволят избежать конфликтов пространств имен между разными, но похожими средами.


== A. Example Desktop Entry File ==

[Desktop Entry]
Version=1.0
Type=Application
Name=Foo Viewer
Comment=The best viewer for Foo objects available!
TryExec=fooview
Exec=fooview %F
Icon=fooview
MimeType=image/x-foo;
Actions=Gallery;Create;

[Desktop Action Gallery]
Exec=fooview --gallery
Name=Browse Gallery

[Desktop Action Create]
Exec=fooview --create-new
Name=Create a new Foo!
Icon=fooview-new


== B. Зарезервированно для использования с KDE ==

По историческим причинам KDE использует некоторые расширения, специфичные для KDE, которые в настоящее время не имеют префикса <code>X-KDE-</code>.

 * Cпецифичные ключи KDE: <code>ServiceTypes</code>, <code>DocPath</code>, <code>InitialPreference</code>
 * Специфичные типы: <code>ServiceType</code>, <code>Service</code> <code>FSDevice</code>

KDE так же использовало ключ <code>Keywords</code> до того как он был стандартизирован, и использует запятые вместо точек с запятой в качестве разделителя. На момент стандартизации поле имело префикс <code>X-KDE</code>, но форк Trinity по-прежнему использовала вариант без префикса.

KDE использует следующие дополнительные ключи для записей рабочего стола типа «FSDevice».

''' Таблица B.1. FSDevice Специфичные Ключи '''

{| class="wikitable" style="margin:auto"
|+ Caption text
|-
! '''Ключ''' !! '''Описание''' !! '''Тип значения'''
| Dev || Устройство для монтирования. || string
|-
| FSType || Тип файловой системы для монтирования. || string
|-
| Exec ||  || string
|-
| MountPoint || Тип файловой системы для монтирования. || string
|-
| ReadOnly || Указывает, доступно ли устройство только для чтения. || boolean
|-
| UnmountIcon || Значок, отображаемый, когда устройство не подключено. Подключенные устройства отображают значок ключа <code>Icon</code>. ||  icostring
|}


== C. Устаревшие Элементы ==

Поскольку этот стандарт довольно старый, в нем есть некоторые устаревшие элементы, которые могут использоваться или не использоваться в некоторых реализациях.

 * <code>Type=MimeType</code> устарел, так как для него существует новый стандарт; дополнительную информацию [https://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec/ см. в спецификации общей базы данных MIME-infoo]. В результате ключ  <code>Patterns</code> (различные расширения имен файлов, связанные с типом MIME) и <code>DefaultApp</code> (приложение по умолчанию, связанное с этим типом MIME) также считаются устаревшими.
 * Использование <code>.kdelnk</code> вместо <code>.desktop</code> поскольку расширение файла устарело.
 * Использование <code>[KDE Desktop Entry]</code> вместо <code>[Desktop Entry]</code> как заголовок группы устарел.
 * Ключ кодировки устарел. Он использовался для указания, были ли ключи типа localestring закодированы в UTF-8 или в указанной локали. Возможные значения: UTF-8 и Legacy-Mixed. Дополнительную информацию см. в Приложении D, Устаревшая смешанная кодировка (устарела).
[[#Список типов ресурсов]]

[[#Спецификация категорий]]



https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html


https://www.mediawiki.org/wiki/Help:Formatting

https://freedesktop.org/wiki/Specifications/icon-theme-spec/

[Desktop Entry]
Type=Application
Name=Test
Icon=/home/luke/Pictures/icon.png
Exec=/home/luke/bin/test.sh
Terminal=false
Categories=Development;
Actions=ActionTest;

[Desktop Action ActionTest]
Name=Action Test
Exec=/home/luke/bin/test-action.sh
